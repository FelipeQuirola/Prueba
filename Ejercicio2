# -*- coding: utf-8 -*-


"""
Python 3
17 / 07 / 2024
@author: z_tjona

"I find that I don't understand things unless I try to program them."
-Donald E. Knuth
"""


# ----------------------------- logging --------------------------
import logging
from sys import stdout
from datetime import datetime

logging.basicConfig(
    level=logging.INFO,
    format="[%(asctime)s][%(levelname)s] %(message)s",
    stream=stdout,
    datefmt="%m-%d %H:%M:%S",
)
logging.info(datetime.now())

import numpy as np

from typing import Callable

from src import eliminacion_gaussiana


# ####################################################################
def ajustar_min_cuadrados(
    xs: list,
    ys: list,
    gradiente: list[Callable[[list[float], list[float]], tuple]],
) -> np.ndarray:
    """Resuelve el sistema de ecuaciones para encontrar los parámetros del método de mínimos cuadrados. Plantea el sistema de ecuaciones lineales al reemplazar los valores de ``xs`` y ``ys`` en las derivadas parciales.

    ## Parameters

    ``xs``: lista con los valores de x.

    ``ys``: lista con los valores de y.

    ``fcn``: función que se ajustará a los datos.

    ``gradiente``: lista con las funciones de derivadas parciales de ``fcn``.
    [IMPORTANTE] Cada función debe ser de la forma ``der_parcial(xi, yi)->``.

    ## Return

    ``a``:

    """

    assert len(xs) == len(ys), "xs y ys deben tener la misma longitud."

    n = len(xs)

    num_pars = len(gradiente)
    logging.info(f"Se ajustarán {num_pars} parámetros.")
    # --- construir matriz A y vector b
    Ab = np.zeros((num_pars, num_pars + 1), dtype=float)

    for i, der_parcial in enumerate(gradiente):
        assert callable(der_parcial), "Cada derivada parcial debe ser una función."

        Ab[i, :] = der_parcial(xs, ys)

    return eliminacion_gaussiana(Ab)

def derivadas_parciales_cuadraticas(xs: list, ys: list) -> np.ndarray:
    """Calcula las derivadas parciales para una función cuadrática ax^2 + bx + c."""
    A = np.zeros((3, 4))
    n = len(xs)
    A[0, 0] = n
    A[0, 1] = np.sum(xs)
    A[0, 2] = np.sum(np.square(xs))
    A[0, 3] = np.sum(ys)
    
    A[1, 0] = np.sum(xs)
    A[1, 1] = np.sum(np.square(xs))
    A[1, 2] = np.sum(np.power(xs, 3))
    A[1, 3] = np.sum(np.multiply(xs, ys))
    
    A[2, 0] = np.sum(np.square(xs))
    A[2, 1] = np.sum(np.power(xs, 3))
    A[2, 2] = np.sum(np.power(xs, 4))
    A[2, 3] = np.sum(np.multiply(np.square(xs), ys))
    
    return A

# -----------------------------------------------------------------
# Graficar la función cuadrática y los puntos dados
import matplotlib.pyplot as plt

def graficar_funcion_cuadratica(xs: list, ys: list, coeficientes: np.ndarray) -> None:
    """Grafica los puntos dados y la función cuadrática ajustada."""
    # Puntos originales
    plt.scatter(xs, ys, color='red', label='Datos')

    # Función cuadrática ajustada
    x_fit = np.linspace(min(xs), max(xs), 100)
    y_fit = coeficientes[0] + coeficientes[1] * x_fit + coeficientes[2] * np.square(x_fit)
    plt.plot(x_fit, y_fit, label='Ajuste cuadrático', color='blue')

    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.show()
